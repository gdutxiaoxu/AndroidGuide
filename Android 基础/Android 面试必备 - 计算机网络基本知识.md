## 前言

最近准备更新 Android 面试必备基础知识系列，有兴趣的可以关注我的微信公众号 **stormjun94**，有更新时，第一时间会在微信公众号上面发布，同时，也会同步在 GitHub 上面更新，如果觉得对你有所帮助的话，请帮忙 star。

[Android 面试必备 - http 与 https 协议](https://blog.csdn.net/gdutxiaoxu/article/details/97885526)

[Android 面试必备 - 计算机网络基本知识（TCP，UDP，Http，https）](https://blog.csdn.net/gdutxiaoxu/article/details/97618598)

[Android 面试必备 - 线程](https://blog.csdn.net/gdutxiaoxu/article/details/98475465)

[Android 面试必备 - JVM 及 类加载机制](https://xujun.blog.csdn.net/article/details/98896053)

[Android 面试必备 - 系统、App、Activity 启动过程](https://xujun.blog.csdn.net/article/details/99006458)


**[Android_interview github 地址](https://github.com/gdutxiaoxu/Android_interview)**


![stormjun94](https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy8yMDUwMjAzLWY1MWIxMjk1MDM5N2E0YzU)

---

## 简介

HTTP协议（超文本传输协议）和 UDP（用户数据包协议），TCP 协议（传输控制协议）

TCP/IP是个协议组，可分为四个层次：网络接口层、网络层、传输层和应用层。
在网络层有IP协议、ICMP协议、ARP协议、RARP协议和BOOTP协议。
在传输层中有TCP协议与UDP协议，arq协议。
在应用层有FTP、HTTP、TELNET、SMTP、DNS等协议。

![enter description here](https://www.github.com/gdutxiaoxu/blog_pic/raw/master/xiaoshujian/2019_6/1560156322893.png)


## TCP 与 UDP

### TCP与UDP基本区别


![enter description here](https://www.github.com/gdutxiaoxu/blog_pic/raw/master/xiaoshujian/2019_6/1560156342920.png)


UDP与TCP的区别与联系
一：UDP是面向无连接的协议，TCP 是面向连接的协议
UDP发出请求后，即发送数据之前不需要先连接，TCP 发送数据之前需要先连接
二：UDP 相对TCP来说是不可靠的
因为 UDP 在发送数据以后，没有采用超时重发，停止等待机制，拥塞控制
三：TCP 面向流，UDP 面向报文

### TCP优缺点：

优点：可靠，稳定

TCP的可靠体现在TCP在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源。

缺点：

- 慢，效率低，占用系统资源高，易被攻击 
TCP在传递数据之前，要先建连接，这会消耗时间，而且在数据传递时，确认机制、重传机制、拥塞控制机制等都会消耗大量的时间，而且要在每台设备上维护所有的传输连接，事实上，每个连接都会占用系统的CPU、内存等硬件资源。 
- 而且，因为TCP有确认机制、三次握手机制，这些也导致TCP容易被人利用，实现DOS、DDOS、CC等攻击。



### UDP优缺点：
优点：
- 快，比TCP稍安全 
- UDP没有TCP的握手、确认、窗口、重传、拥塞控制等机制，UDP是一个无状态的传输协议，所以它在传递数据时非常快。没有TCP的这些机制，UDP较TCP被攻击者利用的漏洞就要少一些。但UDP也是无法避免攻击的，比如：UDP Flood攻击……

缺点：
-  不可靠，不稳定 。因为UDP没有TCP那些可靠的机制，在数据传递时，如果网络质量不好，就会很容易丢包。

　　

  ### 三次握手与四次挥手
  
  **三次握手**
  
第一次握手:第一次连接时，客户端向服务器端发送SYN（syn=j），等待服务器端的确认，此时客户端进入SYN_SEND状态，SYN：同步序列号

第二次握手：服务器端收到客户端发来的SYN，必须向客户端发送ACK包（ack=j+1=k），同时自己必须发送一个SYN包，即syn+ack，此时进入SYN_REC状态

第三次握手：客户端收到服务器端发来的syn+ack包，向服务器发送ack包（ack=k+1),发送完毕，此时进入ESTABLISH状态，连接成功，完成第三次连接。


```
发送                  确认


第一次：SYN=1       SEQ=X               ACK=0（客）
第二次：SYN=1       SEQ=Y               ACK=X+1（服）
第三次：            SEQ=X+1             ACK=Y+1（客）
```


**4次挥手**

1. 当主机A完成数据传输后,将控制位FIN置1,提出停止TCP连接的请求 
A进入终止等待1（FIN-WAIT-1）状态
2. 主机B收到FIN后对其作出响应,确认这一方向上的TCP连接将关闭,将ACK置1
tcp处于半关闭状态（half-close）
a收到b端的确认后，就进入终止等待2状态
3. 由B 端再提出反方向的关闭请求,将FIN置1
进入last-wait状态
4. 主机A对主机B的请求进行确认,将ACK置1,双方向的关闭结束.
进入时间等待状态（time-wait）
时间等待计数器设置的时间过了2msl以后，进入closed状态



**三次握手的原因**

如果只有两次握手的话，比如说失效的报文段，突然发送到服务端，服务端收到失效报文段的请求后，会发送确认报文，新的连接就建立起来了。但现在由于客户端并没有发出请求，所以并不会理睬服务端的确认，也不会像服务端发送数据。而服务端以为已经连接起来了，一直在等待，浪费资源。

**四次挥手的原因**


TCP建立连接要进行3次握手,而断开连接要进行4次,这是由于TCP的半关闭造成的,因为TCP连接是全双工的(
即数据可在两个方向上同时传递)所以进行关闭时每个方向上都要单独进行关闭,这个单方向的关闭就叫半关闭.

关闭的方法是一方完成它的数据传输后,就发送一个FIN来向另一方通告将要终止这个方向的连接.当一端收到一个FIN,它必须
通知应用层TCP连接已终止了这个方向的数据传送,发送FIN通常是应用层进行关闭的结果.



###  名词解释

ACK TCP报头的控制位之一,对数据进行确认.确认由目的端发出,用它来告诉发送端这个序列号之前的数据段
都收到了.比如,确认号为X,则表示前X-1个数据段都收到了,只有当ACK=1时,确认号才有效,当ACK=0时,确认号无效,这时会要求重传数据,保证数据的完整性.
SYN 同步序列号,TCP建立连接时将这个位置1
FIN 发送端完成发送任务位,当TCP完成数据传输需要断开时,提出断开连接的一方将这位置1

---

## Http 与 https

Http 是在应用层上的传输协议，底层是 TCP 协议实现的，
它一种面向无状态的连接，短连接，
之所以说他无状态，是因为在每一次请求完成之后，都会把连接关了，不会记住是哪一个客户端连接。

**四种请求方式**
get，post，pull，delete

**请求信息有请求行，请求头，请求正文**

请求行：请求方式，请求地址，请求协议
请求头：头名称，头值
请求正文：（只有post请求才会有）

**响应信息有相应行，响应头，响应正文**

响应行：响应协议，状态码，状态信息
响应 头：头名称和头值
响应正文




### Http1.0与Http1.1，Http2.0的区别



http 2.0采用二进制的格式传送数据，不再使用文本格式传送数据
http2.0对消息头采用hpack压缩算法，http1.x的版本消息头带有大量的冗余消息
http2.0 采用多路复用，即用一个tcp连接处理所有的请求，真正意义上做到了并发请求，流还支持优先级和流量控制
http2.0支持server push，服务端可以主动把css，jsp文件主动推送到客户端，不需要客户端解析HTML，再发送请求，当客户端需要的时候，它已经在客户端了。

- Http1.0一次只能处理一个请求和响应，Http1.1一次能处理多个请求和响应
- 多个请求和响应过程可以重叠
- 增加了更多的请求头和响应头，比如Host、If-Unmodified-Since请求头等

### http和https的区别

https相当于http加上安全套接字，采用ssl加密技术

主要的区别
1. 在osi模型中，http工作于应用层，https工作与传输层
2. http传输的时候采用明文传输，https采用加密传输
3. http不需要证书，https需要响应额证书
4. http以http开头，默认端口是80，https 以https开头，默认的端口是243


上传视频的时候为什么不用 Http 协议？

因为上传视频的时候文件一般比较长，如果我们采用 post 请求的话，写到输出流中，它并不会直接写到服务器中，而是会缓存在内存中，会影响我们的执行效率


---



## 扩展补充

停止等待机制：是指每发送完一个分组，就会停止发送，必须受到对这个分组的确认才会继续发送下一个分组

超时重传：是指每发送一个分组，就会为这个分组启动一个超时计数器，在规定的时间内没有受到确认，就会再次发送这个分组。

在连续ARQ协议中，为提高信道利用率，通常采取的做法是发送方维持一个发送窗口，凡是位于该窗口内的分组都可以发送出去，无需等待确认，在接收方是采用累积确认，即对按需到达的分组后一个分组发送确认，表明在这个分组以前的所有分组都已正确接收到


拥塞控制与流量控制

流量控制是一个端到端的过程，是值接收方限制发送方的速率不要太快，使接收方来得及接收；拥塞控制是一个全局的过程，是只不要向网络注入太多的数据，导致链路或者路由器损坏；

拥塞控制采用四种算法：慢开始和拥塞控制，快重传和快恢复

慢开始是cwnd（拥塞窗口）每次回从1开始，每经过一个往返时间，cwnd的值就会加倍；
拥塞避免是指每经过一个往返时间，cwnd的值会加一，是一个线性的过程。
慢开始和拥塞避免:会设置一个慢开始门限，当cwnd《sshreh的时候，会采用满开始算法，当超过这个值的时候，会采用拥塞避免的算法，当出现拥塞的时候，会把sshreh的值取为发送方窗口值当前的一半，再把cwnd取为1，从1开始使用满开始算法。

快重传和快恢复收到三个重复确认的时候，会把sshreh的值置为当前值的一半，与慢开始不同的是，它会把拥塞窗口的值取为当前慢开始门限的一半，执行拥塞避免算法

快重传要求接收方没收到一段失序的报文段，就要向发送方发送一个确认

**洪水攻击**

向服务器端发送大量的伪TCP连接请求，这时候服务器端会进入syn_receive半连接状态，服务器端会尝试发送多次包来确认，因为这些连接时假冒的，所以并不会完成第三次握手，导致服务器端保持大量的半连接状态，耗费资源，是TCP连接队列被塞满。

解决方法：
1.  做一些应急处理，对这些IP地址的特征来禁止响应的IP地址字段的访问。
2.  应急处理毕竟太被动，因为本机房的F5比较空闲，运维利用F5来挡攻击，采用方式：让客户端先和F5三次握手，连接建立之后F5才转发到后端业务服务器。



















 
